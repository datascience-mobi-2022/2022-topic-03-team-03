---
title: "Data_anaylsis_group3.3"
author: "Carina, Maike, Marcel, Mirja"
date: "22 5 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### Load libraries

```{r}
library(tidyverse)
```


### Raw data
```{r label = Load the Data}
#load the data
Raw_data <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/3a0f2d9583b56a1cd22150b399d61352d6f7b0e1/RDeeP_HeLa_Interphase.csv", header=TRUE, row.names=1, sep = ";")
First <- Raw_data[1:10,]
First #first 10 rows
```
```{r}
#Dimension and Class
dim(Raw_data)
class(Raw_data)
range(Raw_data)
```

```{r}
#Col and Rownames 
colnames(Raw_data) # Fractions
rownames(First) # Proteinnames
```

###Normalization

```{r label = reorganise coulums}
#reorganize the coulumns
# if necessary install.packages("tidyverse")
library(tidyverse)
# Control
HeLa_Ctrl = Raw_data %>% select(contains("Ctrl")) 
HeLa_Ctrl1 = HeLa_Ctrl %>% select(contains("Rep1"))
HeLa_Ctrl2 = HeLa_Ctrl %>% select(contains("Rep2"))
HeLa_Ctrl3 = HeLa_Ctrl %>% select(contains("Rep3"))

# RNAse
HeLa_RNAse = Raw_data %>% select(contains("RNA"))
HeLa_RNAse1 = HeLa_RNAse %>% select(contains("Rep1"))
HeLa_RNAse2 = HeLa_RNAse %>% select(contains("Rep2"))
HeLa_RNAse3 = HeLa_RNAse %>% select(contains("Rep3"))

HeLa_ordered = data.frame(HeLa_Ctrl1, HeLa_RNAse1, HeLa_Ctrl2, HeLa_RNAse2, HeLa_Ctrl3, HeLa_RNAse3) # crtl, RNAseHeLa_RNAse1
```


```{r label = rows of 0}
# Rows of 0
which(rowMeans(Raw_data) == 0) #nur eine Zeile komplett ohne Werte
which(rowMeans(HeLa_RNAse) == 0) #2 Reihen ohne Werte
which(rowMeans(HeLa_Ctrl) == 0)# 4Reihen ohne Werte
trash <- c(which(rowMeans(HeLa_Ctrl) == 0),which(rowMeans(HeLa_RNAse) == 0))
trash <- trash[-5] #kommt in beiden Reihen vor 
trash # 5 Proteine die wir nicht nutzen kÃ¶nnen

```

```{r}
#remove failed proteins
HeLa_cleaned <- Raw_data[- trash, ]
dim(HeLa_cleaned) #dataset without rows of 0

```

```{r NA}
HeLa_cleaned_NA <- HeLa_cleaned # make a copy
HeLa_cleaned_NA[HeLa_cleaned_NA == 0] <- NA # Replace 0 with NA
```

```{r label = clean up}
#clean up datasets
# Control
HeLa_Ctrl = HeLa_cleaned %>% select(contains("Ctrl")) 
HeLa_Ctrl1 = HeLa_Ctrl %>% select(contains("Rep1"))
HeLa_Ctrl2 = HeLa_Ctrl %>% select(contains("Rep2"))
HeLa_Ctrl3 = HeLa_Ctrl %>% select(contains("Rep3"))

# RNAse
HeLa_RNAse = HeLa_cleaned %>% select(contains("RNA"))
HeLa_RNAse1 = HeLa_RNAse %>% select(contains("Rep1"))
HeLa_RNAse2 = HeLa_RNAse %>% select(contains("Rep2"))
HeLa_RNAse3 = HeLa_RNAse %>% select(contains("Rep3"))
```

```{r Anteile}
#Rowpercent <- kann so bleiben
 rowPercent <- function(dataframe){
     dt <- dataframe
     lastrow <- dim(dataframe)[1]
     for(i in 1:lastrow){
         RowSum <- rowSums (dataframe[i,])
         dt[i,] <- (dataframe[i,]/RowSum)*100      
     }
     return(dt)
 }

#Spalten normalisieren
Spalten_Norm <- function(x){
  ColSumme = colSums(x)
  maxcolsums = c()
  k = 3
  for (i in 1:(ncol(x)/3)) {
    a = ColSumme[[k*i]]
    b = ColSumme[[k*i-1]]
    c = ColSumme[[k*i-2]]
    maxcolsums = c(maxcolsums, max(a,b,c))
  }
  return(ColSumme)
}
Spalten_Norm_1 <- function(x){
  ColSumme = colSums(x)
  maxcolsums = c()
  k = 3
  for (i in 1:(ncol(x)/3)) {
    a = ColSumme[[k*i]]
    b = ColSumme[[k*i-1]]
    c = ColSumme[[k*i-2]]
    maxcolsums = c(maxcolsums, max(a,b,c))
  }
  return(maxcolsums)
}
Spalten_Norm_2 <- function(x, ColSumme, maxcolsums){
  Quotient = c()
  k = 3
  for (i in 1:(ncol(x)/3)){
    Quotient = c(Quotient, maxcolsums[i]/ColSumme[[k*i-2]])
    Quotient = c(Quotient, maxcolsums[i]/ColSumme[[k*i-1]])
    Quotient = c(Quotient, maxcolsums[i]/ColSumme[[k*i]])
  }
  return(Quotient)
}



#colPercent <- function(dataframe){
     #dt <- dataframe
     #lastcol <- dim(dataframe)[2]
     #for(i in 1:lastcol){
         #ColSum <- colSums (dataframe[,i, drop = FALSE])
         #dt[,i] <- (dataframe[,i]/ColSum)*100      
     #}
     #return(dt)
#}

```

```{r}
#Spalten normalisieren
ColSumme<- Spalten_Norm(HeLa_cleaned)
maxcolsums <- Spalten_Norm_1(HeLa_cleaned)
Quotient <- Spalten_Norm_2(HeLa_cleaned, ColSumme, maxcolsums)
Hela_Col_Norm <- sweep(HeLa_cleaned, 2, Quotient, "*")
Hela_Row_Norm <- rowPercent(Hela_Col_Norm) 
```

```{r}
# Alternativ Spalten

#normalisieren = function(x) {
  #colsummen = colSums(x)
 # maxcolsums = c()
 # l = 3
  #for (i in 1:(ncol(x)/3)) {
  #  x = colsummen[[l*i]]
   # y = colsummen[[l*i-1]]
  #  z = colsummen[[l*i-2]]
  #  maxcolsums = c(maxcolsums, max(x,y,z))
  #}
 # factors = c()
 # l = 3
  #for (i in 1:(ncol(x)/3)) {
  #  factors = c(factors, maxcolsums[i]/colsummen[[l*i-2]])
   # factors = c(factors, maxcolsums[i]/colsummen[[l*i-1]])
   # factors = c(factors, maxcolsums[i]/colsummen[[l*i]])
#  }
 # sweep(mouse_data, 2, factors, "*")
#}
```


```{r}
Norm_Hela <- Hela_Row_Norm
```

### Create separate dataframes

Next, dataframes for each individual fraction and treatment option are created, containing the triplicate values for each protein. 

They follow the naming convention: 
- Fraction1_Ctrl for the triplicate values of first fraction of the control group
- Fraction_8_RNAse for the triplicate values of eighth fraction of the RNase treated sample

```{r label = Fractions}
#select the fractions
HeLa_Fractions  <- Norm_HeLa

# Create list of all separate dataframes for the fractions
library(tidyverse)

fractions_names <-  sapply(c(1:50), function(x) {
  if (x%%2 == 0) 
    str_glue("Fraction", (x/2), "_RNAse")
  else 
    str_glue("Fraction", ((x+1)/2), "_Ctrl")
})

# Assign the names to the according 
for (i in c(1:50)) {
  assign(fractions_names[i], HeLa_Fractions[,(3*i-2):(3*i)])
}

# Test
Fraction1_Ctrl
Fraction8_RNAse
```


```{r mean}
#mean 
mean_bestof3 <- function(x) {
				if( (abs(x[1]-x[2])<abs(x[1]-x[3])) && (abs(x[1]-x[2])<abs(x[2]-x[3])) ) {
					mean(c(x[1],x[2]))} 
        else if( (abs(x[1]-x[3])<abs(x[1]-x[2])) && (abs(x[1]-x[3])<abs(x[2]-x[3])) ) {
					mean(c(x[1],x[3]))} else {mean(c(x[2],x[3]))} 
}

```


```{r}
# 20% Mean Function
mean_20 <- function(x) {
              mean <- mean(x)
             if (abs(x[1] - mean) > 0.2 * mean) { x[1] <- NA}
              if (abs(x[2] - mean) > 0.2 * mean) { x[2] <- NA}
       if (abs(x[3] - mean) > 0.2 * mean) { x[3] <- NA}
          
                mean(x, na.rm = TRUE) }
```

```{r Standardabweichung}
# Use sd to single out outliers

mean_sd <- function(x) {
        m <- mean(x)
        s <- sd(x)
       for (i in 1:3)
        if (( (m - 3 * s) > x[i]) || ((m + 3 * s) < x[i])) { x[i] <- NA}
 mean(x, na.rm =TRUE) }
        
   

 Test <- Fraction1_Ctrl[1:5,]
 Mean_Test <- apply(Test, 1, mean_sd)
 Mean_Test
```

 
```{r}
#Mittelwerte berechnen

mean_Ctrl1 <- apply(Fraction1_Ctrl, 1,mean_sd)
mean_Ctrl2 <- apply(Fraction2_Ctrl, 1,mean_sd )
mean_Ctrl3 <- apply(Fraction3_Ctrl, 1,mean_sd )
mean_Ctrl4 <- apply(Fraction4_Ctrl, 1,mean_sd )
mean_Ctrl5 <- apply(Fraction5_Ctrl, 1,mean_sd)
mean_Ctrl6 <- apply(Fraction6_Ctrl, 1,mean_sd)
mean_Ctrl7 <- apply(Fraction7_Ctrl, 1,mean_sd)
mean_Ctrl8 <- apply(Fraction8_Ctrl, 1,mean_sd)
mean_Ctrl9 <- apply(Fraction9_Ctrl, 1,mean_sd)
mean_Ctrl10 <- apply(Fraction10_Ctrl, 1, mean_sd)
mean_Ctrl11 <- apply(Fraction11_Ctrl, 1,mean_sd)
mean_Ctrl12 <- apply(Fraction12_Ctrl, 1,mean_sd)
mean_Ctrl13 <- apply(Fraction13_Ctrl, 1,mean_sd)
mean_Ctrl14 <- apply(Fraction14_Ctrl, 1,mean_sd)
mean_Ctrl15 <- apply(Fraction15_Ctrl, 1,mean_sd)
mean_Ctrl16 <- apply(Fraction16_Ctrl, 1,mean_sd)
mean_Ctrl17 <- apply(Fraction17_Ctrl, 1,mean_sd)
mean_Ctrl18 <- apply(Fraction18_Ctrl, 1,mean_sd)
mean_Ctrl19 <- apply(Fraction19_Ctrl, 1,mean_sd)
mean_Ctrl20 <- apply(Fraction20_Ctrl, 1,mean_sd)
mean_Ctrl21 <- apply(Fraction21_Ctrl, 1,mean_sd)
mean_Ctrl22 <- apply(Fraction22_Ctrl, 1,mean_sd)
mean_Ctrl23 <- apply(Fraction23_Ctrl, 1,mean_sd)
mean_Ctrl24 <- apply(Fraction24_Ctrl, 1,mean_sd)
mean_Ctrl25 <- apply(Fraction25_Ctrl, 1,mean_sd)

mean_RNAse1 <- apply(Fraction1_RNAse, 1,mean_sd)
mean_RNAse2 <- apply(Fraction2_RNAse, 1,mean_sd)
mean_RNAse3 <- apply(Fraction3_RNAse, 1,mean_sd)
mean_RNAse4 <- apply(Fraction4_RNAse, 1,mean_sd)
mean_RNAse5 <- apply(Fraction5_RNAse, 1,mean_sd)
mean_RNAse6 <- apply(Fraction6_RNAse, 1,mean_sd)
mean_RNAse7 <- apply(Fraction7_RNAse, 1,mean_sd)
mean_RNAse8 <- apply(Fraction8_RNAse, 1,mean_sd)
mean_RNAse9 <- apply(Fraction9_RNAse, 1,mean_sd)
mean_RNAse10 <- apply(Fraction10_RNAse, 1,mean_sd)
mean_RNAse11 <- apply(Fraction11_RNAse, 1,mean_sd)
mean_RNAse12 <- apply(Fraction12_RNAse, 1,mean_sd)
mean_RNAse13 <- apply(Fraction13_RNAse, 1,mean_sd)
mean_RNAse14 <- apply(Fraction14_RNAse, 1,mean_sd)
mean_RNAse15 <- apply(Fraction15_RNAse, 1,mean_sd)
mean_RNAse16 <- apply(Fraction16_RNAse, 1,mean_sd)
mean_RNAse17 <- apply(Fraction17_RNAse, 1,mean_sd)
mean_RNAse18 <- apply(Fraction18_RNAse, 1,mean_sd)
mean_RNAse19 <- apply(Fraction19_RNAse, 1,mean_sd)
mean_RNAse20 <- apply(Fraction20_RNAse, 1,mean_sd)
mean_RNAse21 <- apply(Fraction21_RNAse, 1,mean_sd)
mean_RNAse22 <- apply(Fraction22_RNAse, 1,mean_sd)
mean_RNAse23 <- apply(Fraction23_RNAse, 1,mean_sd)
mean_RNAse24 <- apply(Fraction24_RNAse, 1,mean_sd)
mean_RNAse25 <- apply(Fraction25_RNAse, 1,mean_sd)

# Dataframe with mean
mean_HeLa <- data.frame(mean_Ctrl1, mean_RNAse1, mean_Ctrl2, mean_RNAse2, mean_Ctrl3,mean_RNAse3, mean_Ctrl4, mean_RNAse4,  mean_Ctrl5, mean_RNAse5, mean_Ctrl6, mean_RNAse6, mean_Ctrl7, mean_RNAse7, mean_Ctrl8, mean_RNAse8, mean_Ctrl9, mean_RNAse9, mean_Ctrl10, mean_RNAse10, mean_Ctrl11, mean_RNAse11, mean_Ctrl12, mean_RNAse12, mean_Ctrl13, mean_RNAse13, mean_Ctrl14, mean_RNAse14, mean_Ctrl15, mean_RNAse15, mean_Ctrl16, mean_RNAse16, mean_Ctrl17, mean_RNAse17, mean_Ctrl18, mean_RNAse18, mean_Ctrl19, mean_RNAse19, mean_Ctrl20, mean_RNAse20, mean_Ctrl21, mean_RNAse21, mean_Ctrl22, mean_RNAse22, mean_Ctrl23, mean_RNAse23, mean_Ctrl24, mean_RNAse24, mean_Ctrl25, mean_RNAse25)
```

```{r Fraktionenverlust}
out3 <- sum(is.na(mean_HeLa))
out3 # Fraktionen die wir so raus kicken
50 *7081 #Gesammtsumme an Fraktionen
```

```{r label = clean up}
#clean up datasets
# Control
HeLa_Ctrl_mean = mean_HeLa %>% select(contains("Ctrl")) 

# RNAse
HeLa_RNAse_mean = mean_HeLa %>% select(contains("RNA"))

```

```{r sd}
#Standardabweichung berechnen
sd_Ctrl1 <- apply(Fraction1_Ctrl, 1,sd)
sd_Ctrl2 <- apply(Fraction2_Ctrl, 1,sd)
sd_Ctrl3 <- apply(Fraction3_Ctrl, 1,sd)
sd_Ctrl4 <- apply(Fraction4_Ctrl, 1,sd)
sd_Ctrl5 <- apply(Fraction5_Ctrl, 1,sd)

sd_Ctrl6 <- apply(Fraction6_Ctrl, 1,sd)
sd_Ctrl7 <- apply(Fraction7_Ctrl, 1,sd)
sd_Ctrl8 <- apply(Fraction8_Ctrl, 1,sd)
sd_Ctrl9 <- apply(Fraction9_Ctrl, 1,sd)
sd_Ctrl10 <- apply(Fraction10_Ctrl, 1,sd)

sd_Ctrl11 <- apply(Fraction11_Ctrl, 1,sd)
sd_Ctrl12 <- apply(Fraction12_Ctrl, 1,sd)
sd_Ctrl13 <- apply(Fraction13_Ctrl, 1,sd)
sd_Ctrl14 <- apply(Fraction14_Ctrl, 1,sd)
sd_Ctrl15 <- apply(Fraction15_Ctrl, 1,sd)

sd_Ctrl16 <- apply(Fraction16_Ctrl, 1,sd)
sd_Ctrl17 <- apply(Fraction17_Ctrl, 1,sd)
sd_Ctrl18 <- apply(Fraction18_Ctrl, 1,sd)
sd_Ctrl19 <- apply(Fraction19_Ctrl, 1,sd)
sd_Ctrl20 <- apply(Fraction20_Ctrl, 1,sd)

sd_Ctrl21 <- apply(Fraction21_Ctrl, 1,sd)
sd_Ctrl22 <- apply(Fraction22_Ctrl, 1,sd)
sd_Ctrl23 <- apply(Fraction23_Ctrl, 1,sd)
sd_Ctrl24 <- apply(Fraction24_Ctrl, 1,sd)
sd_Ctrl25 <- apply(Fraction25_Ctrl, 1,sd)



sd_RNAse1 <- apply(Fraction1_RNAse, 1,sd)
sd_RNAse2 <- apply(Fraction2_RNAse, 1,sd)
sd_RNAse3 <- apply(Fraction3_RNAse, 1,sd)
sd_RNAse4 <- apply(Fraction4_RNAse, 1,sd)
sd_RNAse5 <- apply(Fraction5_RNAse, 1,sd)

sd_RNAse6 <- apply(Fraction6_RNAse, 1,sd)
sd_RNAse7 <- apply(Fraction7_RNAse, 1,sd)
sd_RNAse8 <- apply(Fraction8_RNAse, 1,sd)
sd_RNAse9 <- apply(Fraction9_RNAse, 1,sd)
sd_RNAse10 <- apply(Fraction10_RNAse, 1,sd)

sd_RNAse11 <- apply(Fraction11_RNAse, 1,sd)
sd_RNAse12 <- apply(Fraction12_RNAse, 1,sd)
sd_RNAse13 <- apply(Fraction13_RNAse, 1,sd)
sd_RNAse14 <- apply(Fraction14_RNAse, 1,sd)
sd_RNAse15 <- apply(Fraction15_RNAse, 1,sd)

sd_RNAse16 <- apply(Fraction16_RNAse, 1,sd)
sd_RNAse17 <- apply(Fraction17_RNAse, 1,sd)
sd_RNAse18 <- apply(Fraction18_RNAse, 1,sd)
sd_RNAse19 <- apply(Fraction19_RNAse, 1,sd)
sd_RNAse20 <- apply(Fraction20_RNAse, 1,sd)

sd_RNAse21 <- apply(Fraction21_RNAse, 1,sd)
sd_RNAse22 <- apply(Fraction22_RNAse, 1,sd)
sd_RNAse23 <- apply(Fraction23_RNAse, 1,sd)
sd_RNAse24 <- apply(Fraction24_RNAse, 1,sd)
sd_RNAse25 <- apply(Fraction25_RNAse, 1,sd)

#Dataframe with sd
sd_HeLa <- data.frame(sd_Ctrl1, sd_RNAse1, sd_Ctrl2, sd_RNAse2, sd_Ctrl3,sd_RNAse3, sd_Ctrl4, sd_RNAse4,  sd_Ctrl5, sd_RNAse5, sd_Ctrl6, sd_RNAse6, sd_Ctrl7, sd_RNAse7, sd_Ctrl8, sd_RNAse8, sd_Ctrl9, sd_RNAse9, sd_Ctrl10, sd_RNAse10, sd_Ctrl11, sd_RNAse11, sd_Ctrl12, sd_RNAse12,sd_Ctrl13, sd_RNAse13, sd_Ctrl14, sd_RNAse14, sd_Ctrl15, sd_RNAse15, sd_Ctrl16, sd_RNAse16, sd_Ctrl17, sd_RNAse17, sd_Ctrl18, sd_RNAse18, sd_Ctrl19, sd_RNAse19, sd_Ctrl20,sd_RNAse20, sd_Ctrl21, sd_RNAse21, sd_Ctrl22,sd_RNAse22, sd_Ctrl23, sd_RNAse23, sd_Ctrl24, sd_RNAse24, sd_Ctrl25, sd_RNAse25)
```




# Checking on the normalization

Next, the results of the clean-up were compared. We plotted the data pre- and post-normalization for six proteins. Three of which were sure "shifters" and three that were found not to be RNA-dependent.

"Shifters": SIN3A (transcriptional repressor), HDAC1 (Histone deacetylase 1), HNRPU (Heterogeneous nuclear ribonucleoprotein U)

"Non-shifters": ASNS (Asparagine synthetase), MCM2 (DNA replication licensing factor MCM2), MCM3 (DNA replication licensing factor MCM3)

```{r Comparing pre- and post-normalization}
fraction_index <- c(1:25)

# Repeat the following code block for the six test proteins ctrl vs RNase and pre vs post normalization

# Function to create comparison plots

compare_pre_post <- function(protein, y_limit_pre, y_limit_post) {

  par(mfrow = c(1,2))

  plot(fraction_index, HeLa_Ctrl1[protein,], type = 'l', col = 'forestgreen', # Control pre
      xlab = "Fractions",
      ylab = "Protein amount [arbitrary unit]",
      ylim = c(0,y_limit_pre),
      main = paste(protein, "pre-normalization"))
   lines(x = fraction_index, y = HeLa_RNAse1[protein,], type = 'l', col = 'firebrick2') # RNase pre
   legend(x = "topright",                      # Position
       legend = c("ctrl", "RNase"),           # Legend texts
  col = c('darkgreen', 'red'),           # Line colors
       lwd = 2)                               # Line width

  plot(fraction_index, HeLa_Ctrl_mean[protein,], type = 'l', col = 'forestgreen', # Control post
     xlab = "Fractions",
     ylab = "Protein amount [%]",
     ylim = c(0,y_limit_post),
     main = paste(protein, "post-normalization"))
  lines(x = fraction_index, y = HeLa_RNAse_mean[protein,], type = 'l', col = 'firebrick2') # RNase post
  legend(x = "topright",            
       legend = c("ctrl", "RNase"),           
       col = c('darkgreen', 'red'),         
       lwd = 2) 
}
```

Now we will apply the function to our selection of proteins:

```{r}
# Shifters
compare_pre_post("SIN3A_HUMAN", 3500000, 0.1) #SIN3A
compare_pre_post("HDAC1_HUMAN", 6000000, 0.11) #HDAC1
compare_pre_post("HDAC2_HUMAN", 6500000, 0.15) #HDAC2
compare_pre_post("RFC2_HUMAN", 2500000, 0.05) #RFC2

# Non-Shifters
compare_pre_post("ASNS_HUMAN", 2500000, 0.02) #ASNS
compare_pre_post("MCM2_HUMAN", 15000000, 0.5) #MCM2
compare_pre_post("MCM3_HUMAN", 17000000, 0.3) #MCM3

```


The scale should represent percentages now with the area under the curve equaling 1. Furthermore, peaks should become more visible as well as first "shifts".


## Test if data is normally distributed

### Shapiro-Wilk test

 n should be greater than 3 and no greater than 5000 (we are looking at 3 values per protein)
- in the sample there shouldn't be identical values (exclude from test)
- H0 says that the data is normally distributed
- significance level Î± = 5 % --> H0 is not rejected, if p > Î±

```{r Shapiro-Wilk test function}
# Define Shapiro test function
shapiro_testing <- function(x) {
  if (diff(range(x)) == 0) 
      list()
  else shapiro.test(x)
}

# Create list of all separate dataframes for the fractions
library(tidyverse)

fractions_names <-  sapply(c(1:50), function(x) {
  if (x%%2 == 0) 
    str_glue("Fraction", (x/2), "_RNAse")
  else 
    str_glue("Fraction", ((x+1)/2), "_Ctrl")
})


# Define function to apply shapiro testing to list of names for all fractions
shapiro_on_name_list <- function(list) {
  mean = c()
  for (i in 1:length(list)) {
    df = get(list[i])
    list_results <- apply(df, 1, shapiro_testing)
    p_values <- unlist(lapply(list_results, function(x) {x$p.value}))
    # print p mean value for each fraction
    mean = c(mean, mean(p_values))
  }
  mean
}

# Apply testing to data and testing if all values are greater than 5 %
shapiro_on_name_list(fractions_names) > 0.05
```

Following the Shapiro-Wilk test, we can expect our data three replicate values per protein to be normally distributed.


### Graph via qqplot

```{r qqplot on raw data}
 # Function for qqplot and 
qqplot_line <-  function(x) {
  qqnorm(x)
  qqline(x, col ="red")
}

# Plot first five proteins of Fraction 1 Ctrl
apply(Fraction1_Ctrl[1:5,], 1, qqplot_line)
```
QQplots with three values only do not have great significance. 


### Histogram

```{r histogram for raw data}
apply(Fraction1_Ctrl[1:5,], 1, hist)
```

A histogram with three values only is also not a valid method to test for normal distribution.


## Maxima

### Separate dataframes Ctrl vs RNase

For further analysis, all fractions belonging to the control group and those treated with RNase are saved in separate dataframes.

```{r}
# All control
All_ctrl_norm <- HeLa_Fractions %>% select(contains("Ctrl"))
# All RNase
All_RNAse_norm <- HeLa_Fractions %>% select(contains("RNAse"))




# Create list of all separate dataframes for the fractions
library(tidyverse)

fractions_names_RNAse <-  sapply(c(1:25), function(x) {
    str_glue("Fraction", x, "_RNAse")
})

fractions_names_Ctrl_ <-  sapply(c(1:25), function(x) {
    str_glue("Fraction", x, "_Ctrl")
})



# Define function to calculate mean of all proteins for all fractions

mean_on_name_list <- function(list) {
  mean_ctrl = data.frame()
  for (i in 1:length(list)) {
    df = get(list[i])
    fraction_mean <- apply(df, 1, mean)
    mean_ctrl = cbind(mean_ctrl, fraction_mean)
  }
  mean_ctrl
}

# mean_on_name_list(fractions_names_RNAse)

```

### Local maxima

For all proteins - both in the control group and treated with RNase - the local maxima were determined.

For this purpose, the protein content (y-value) was compared to m neighbors right and left of the analyzed fraction (x-position).

```{r local maxima}
find_peaks <- function (x, m = 2){
     shape <- diff(sign(diff(x, na.pad = FALSE))) # test for second derivative
     pks <- sapply(which(shape < 0), FUN = function(i){ # if second derivative < 0 --> Maximum
        z <- i - m + 1
        z <- ifelse(z > 0, z, 1)
        w <- i + m + 1
        w <- ifelse(w < length(x), w, length(x))
        if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(numeric(0))
    })
     pks <- unlist(pks)
     pks
}

#local_max <- apply(proportions, 2, find_peaks)
#local_max

```

```{r}
for (x in c(1:25)) {
  if (x < 3) 
    # Rand links
  else if (x > 23)
    # Rand rechts
  else
    df[, x]
  
}
  
```


### Absolute maxima

For all proteins - both in the control group and treated with RNase - the absolute maxima were determined.

```{r absolute maxima}
#absolute/global maxima

absolute_max <- apply(proportions, 2, max)
absolute_max


```


```{r}
# Alternativ Maxima

find_peaks <- function (x, m = 2){
     shape <- diff(sign(diff(x, na.pad = FALSE)))
     pks <- sapply(which(shape < 0), FUN = function(i){
        z <- i - m + 1
        z <- ifelse(z > 0, z, 1)
        w <- i + m + 1
        w <- ifelse(w < length(x), w, length(x))
        if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(numeric(0))
    })
     pks <- unlist(pks)
     pks
     
     if ( sum(x[1]>x[2:(m+1)]) == 2 ) {pks <- c(pks, 1)} 
     if ( sum(x[25]>x[24:(25-m)]) == 2 ) {pks <- c(pks, 25)}
     pks <- unlist(pks)
     pks
}

#absolute/global maxima
ctrl_prop <- colPercent(HeLa_Ctrl_mean)
RNAse_prop <- colPercent(HeLa_RNAse_mean)

absolute_max_ctrl <- apply(ctrl_prop, 1, max)
absolute_max_ctrl

absolute_max_RNAse <- apply(RNAse_prop, 1, max)
absolute_max_RNAse

#x is the dataframe with all percentage values of ctrl or RNAse treated sample. Function relevant_peaks gives us the fraction numbers of the relevant peaks (contain more than 2% of the protein).

rel_peaks_ctrl <- apply(HeLa_Ctrl_mean, 1, function(x){
              list <- find_peaks(x)
              list <- list[x[list] > 2]
              list <- unlist(list)
              list
})

rel_peaks_RNAse <- apply(HeLa_RNAse_mean, 1, function(x){
              list <- find_peaks(x)
              list <- list[x[list] > 2]
              list <- unlist(list)
              list
})

rel_peaks_ctrl
rel_peaks_RNAse
```

```{r percentage of maxima (height)}
peaks_ctrl_prop <- HeLa_Ctrl_mean[rel_peaks_ctrl]

peaks_RNAse_prop <- HeLa_RNAse_mean[rel_peaks_RNAse]
```


## Shift Erkennung
```{r}
# Globale Maxima fÃ¼r CNTRL und RNAse in eine Spalte einer Tabelle oder separat

# Lokale Maxima ebenfalls

# Maxima auswÃ¤hlen: Laut Literatur (Maiwens Publikation) alle Maxima >= 25 % des globalen Maximums berÃ¼cksichtigen.

 # Als erstes mÃ¼ssen wir definieren ob der Verlust in der einen Fraktion identisch mit dem Gain in der anderen ist --> ErmÃ¶glicht uns zu erkennen ob mehrere Peaks nach RNASE Treatment zu erwarten sind. Dazu vergleichen wir die "Area under Curve" oder halt die Differenzen der beiden Fraktionen.

# Parameter ob shift relevant: Ãnderung > 1 Fraktion

# Wie bestimmen ? --> "x" Values aka Fraktion bestimmen und subtrahieren --> CNTRL - RNASE wenn Value > 1 (Links Verschiebung) bzw. < -1 (Rechts Verschiebung) dann ist der Shift vorhanden. --> 2 Listen anlegen. Sollte auch nur ganzzahlige Werte liefern.  Zu BerÃ¼cksichtigen sind die Proteine die mehrere Peaks haben bei RNASE --> seperate Liste. LÃ¤sst sich vllt. mit der count Funktion umsetzen. Ausprobieren mit den globalen Maxima.

# Beispiel: 
#RFC2 ist bei CNTRL in Fraktion 21 gloables Maximum . In der RNASE Sample Fraktion 9 macht in der Rechnung: 21-9=12 bedeutet Linksverschiebung. AnschlieÃend "Area under Curve" oder Maxima:
# Beispiel:RFC2_CNTRL(9)=1000, RFC2_CNTRL(21)=15000, RFC2_RNASE(9)=17500, RFC2_RNASE(21)= 200 --> Delta(9) = Delta(21) --> Delta(9)=16500 Delta(21)=14800. Wir sehen die Werte sind nicht gleich, da es biologische Samples sind ggf. +/- 10% erlauben. Vermutlich ist die Varinate mit der Area under Curve die elegantere.
```
## Statistische Tests
```{r}
# WENN die Werte Normalverteilt sind und wir das einfach nur aufgrund der Normalisierung nicht sehen: a) Erst F-Test um die Varianzen zu vergleichen b) Unpaired T-Test weil wir zwar eine einheitliche Grundgesamtheit haben aber diese unterschiedlich behandelt haben. Muss da mal Niklas fragen. 

#Beispiel mit Fe-Werten von MÃ¤usen aus meiner Ausbildung die wir damals hÃ¤ndisch gerechnet haben.

Fe_before <- c(13.6, 13.0, 13.7, 13.9, 13.4)
Fe_after <- c(12.0, 12.3, 13.1, 12.5, 13.0)

Fe_ttest <- t.test(Fe_before, Fe_after, var.equal = TRUE) #Unpired
Fe_ttest

#Wir sehen der p-value ist 0.006618 und damit kleiner als die Signifikanzgrenze (a) bei Konfidenzintervall 95 % a = 0.05 dementsprechend ist es signifikant.

# Man kann auch argumentieren, dass die Werte gepaart sind Vor-Treatment und nach Treatment. So habe ich in der Ausbildung gerechnet. 

Fe_test_paired <- t.test(Fe_before, Fe_after, paired = TRUE)
Fe_test_paired

#Wilcoxon Test for paired samples if not normally ditributed was bei unseren Daten sehr wahrscheinlich der Fall sein wird. 

```