---
title: "Data_anaylsis_group3.3"
author: "Carina, Maike, Marcel, Mirja"
date: "22 5 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### Load libraries

```{r}
library(tidyverse)
```


### Raw data
```{r label = Load the Data}
#load the data
#Raw_data <- read.table("C:\\Users\\Mirja\\Documents\\4. Semester\\Bioinfo\\RDeeP_HeLa_Interphase.csv", header=TRUE, row.names=1, sep = ";")
Raw_data <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/3a0f2d9583b56a1cd22150b399d61352d6f7b0e1/RDeeP_HeLa_Interphase.csv", header=TRUE, row.names=1, sep = ";")
First <- Raw_data[1:10,]#first 10 rows
```

```{r}
#Col and Rownames 
colnames <-  c(colnames(Raw_data)) # Fractions
rownames <- c(rownames(Raw_data)) # Proteinnames
```

###Normalization

```{r split Ctrl and RNAse}

# if necessary install.packages("tidyverse")
library(tidyverse)
# Control
HeLa_Ctrl = Raw_data %>% select(contains("Ctrl")) 

# RNAse
HeLa_RNAse = Raw_data %>% select(contains("RNA"))
```


```{r label = rows of 0}
# Rows of 0
which(rowMeans(Raw_data) == 0) #nur eine Zeile komplett ohne Werte
which(rowMeans(HeLa_RNAse) == 0) #2 Reihen ohne Werte
which(rowMeans(HeLa_Ctrl) == 0)# 4Reihen ohne Werte
trash <- c(which(rowMeans(HeLa_Ctrl) == 0),which(rowMeans(HeLa_RNAse) == 0))
trash <- trash[-5] #kommt in beiden Reihen vor 
trash # 5 Proteine die wir nicht nutzen können

```

```{r remove failed proteins}
#remove failed proteins
HeLa_cleaned <- Raw_data[- trash, ]
dim(HeLa_cleaned) #dataset without rows of 0

```

```{r NA}
HeLa_cleaned_NA <- HeLa_cleaned # make a copy
HeLa_cleaned_NA[HeLa_cleaned_NA == 0] <- NA # Replace 0 with NA
```

```{r Ctrl and RNAse without rows of 0}
#clean up datasets
# Control
HeLa_Ctrl = HeLa_cleaned %>% select(contains("Ctrl")) 

# RNAse
HeLa_RNAse = HeLa_cleaned %>% select(contains("RNA"))



```

```{r Normalise columns}

#Spalten normalisieren
Spalten_Norm <- function(x){
  ColSumme = colSums(x)
  maxcolsums = c()
  k = 3
  for (i in 1:(ncol(x)/3)) {
    a = ColSumme[[k*i]]
    b = ColSumme[[k*i-1]]
    c = ColSumme[[k*i-2]]
    maxcolsums = c(maxcolsums, max(a,b,c))
  }
  return(ColSumme)
}
Spalten_Norm_1 <- function(x){
  ColSumme = colSums(x)
  maxcolsums = c()
  k = 3
  for (i in 1:(ncol(x)/3)) {
    a = ColSumme[[k*i]]
    b = ColSumme[[k*i-1]]
    c = ColSumme[[k*i-2]]
    maxcolsums = c(maxcolsums, max(a,b,c))
  }
  return(maxcolsums)
}
Spalten_Norm_2 <- function(x, ColSumme, maxcolsums){
  Quotient = c()
  k = 3
  for (i in 1:(ncol(x)/3)){
    Quotient = c(Quotient, maxcolsums[i]/ColSumme[[k*i-2]])
    Quotient = c(Quotient, maxcolsums[i]/ColSumme[[k*i-1]])
    Quotient = c(Quotient, maxcolsums[i]/ColSumme[[k*i]])
  }
  return(Quotient)
}

```

```{r }
#Spalten normalisieren
ColSumme<- Spalten_Norm(HeLa_cleaned)
maxcolsums <- Spalten_Norm_1(HeLa_cleaned)
Quotient <- Spalten_Norm_2(HeLa_cleaned, ColSumme, maxcolsums)
Hela_Col_Norm <- sweep(HeLa_cleaned, 2, Quotient, "*")

```

```{r}
# Alternativ Spalten

#normalisieren = function(x) {
  #colsummen = colSums(x)
 # maxcolsums = c()
 # l = 3
  #for (i in 1:(ncol(x)/3)) {
  #  x = colsummen[[l*i]]
   # y = colsummen[[l*i-1]]
  #  z = colsummen[[l*i-2]]
  #  maxcolsums = c(maxcolsums, max(x,y,z))
  #}
 # factors = c()
 # l = 3
  #for (i in 1:(ncol(x)/3)) {
  #  factors = c(factors, maxcolsums[i]/colsummen[[l*i-2]])
   # factors = c(factors, maxcolsums[i]/colsummen[[l*i-1]])
   # factors = c(factors, maxcolsums[i]/colsummen[[l*i]])
#  }
 # sweep(mouse_data, 2, factors, "*")
#}
```

```{r split reps}
# Control
HeLa_Ctrl_colnorm = Hela_Col_Norm %>% select(contains("Ctrl")) 
HeLa_Ctrl1 = HeLa_Ctrl_colnorm %>% select(contains("Rep1"))
HeLa_Ctrl2 = HeLa_Ctrl_colnorm %>% select(contains("Rep2"))
HeLa_Ctrl3 = HeLa_Ctrl_colnorm %>% select(contains("Rep3"))
# RNAse
HeLa_RNAse_colnorm = Hela_Col_Norm %>% select(contains("RNA"))
HeLa_RNAse1 = HeLa_RNAse_colnorm %>% select(contains("Rep1"))
HeLa_RNAse2 = HeLa_RNAse_colnorm %>% select(contains("Rep2"))
HeLa_RNAse3 = HeLa_RNAse_colnorm %>% select(contains("Rep3"))
```

```{r Reihen normalisieren}
# added if so we get 0 instead of Na if RowSum is 0
 rowPercent <- function(dataframe){
     dt <- dataframe
     lastrow <- dim(dataframe)[1]
     for(i in 1:lastrow){
         RowSum <- rowSums (dataframe[i,])
    if (RowSum == 0) {dt[i,] <- 0}
    else dt[i,] <- (dataframe[i,]/RowSum)*100    } 
     return(dt)}
 
 
Norm_HeLa_Ctrl1 <- rowPercent(HeLa_Ctrl1)
Norm_HeLa_Ctrl2 <- rowPercent(HeLa_Ctrl2)
Norm_HeLa_Ctrl3 <- rowPercent(HeLa_Ctrl3)

Norm_HeLa_RNAse1 <- rowPercent(HeLa_RNAse1)
Norm_HeLa_RNAse2 <- rowPercent(HeLa_RNAse2)
Norm_HeLa_RNAse3 <- rowPercent(HeLa_RNAse3)
```

```{r}
Norm_HeLa <- cbind(Norm_HeLa_Ctrl1, Norm_HeLa_Ctrl2, Norm_HeLa_Ctrl3, Norm_HeLa_RNAse1, Norm_HeLa_RNAse2, Norm_HeLa_RNAse3)
```


### Create separate dataframes

Next, dataframes for each individual fraction and treatment option are created, containing the triplicate values for each protein. 

They follow the naming convention: 
- Fraction1_Ctrl for the triplicate values of first fraction of the control group
- Fraction_8_RNAse for the triplicate values of eighth fraction of the RNase treated sample

```{r  Fractions}
#select the fractions
vector <- c(1, 26, 51, 76, 101, 126, 2, 27, 52, 77, 102, 127, 3, 28, 53, 78, 103, 128, 4, 29, 54, 79, 104, 129, 5, 30, 55, 80, 105, 130, 6, 31, 56, 81, 106, 131, 7, 32, 57, 82, 107, 132, 8, 33, 58, 83, 108, 133, 9, 34, 59, 84, 109, 134, 10, 35, 60, 85, 110, 135, 11, 36, 61, 86, 111, 136, 12, 37, 62, 87, 112, 137, 13, 38, 63, 88, 113, 138, 14, 39, 64, 89, 114, 139, 15, 40, 65, 90, 115, 140, 16, 41, 66, 91, 116, 141, 17, 42, 67, 92, 117, 142, 18, 43, 68, 93, 118, 143, 19, 44, 69, 94, 119, 144, 20, 45, 70, 95, 120, 145, 21, 46, 71, 96, 121, 146, 22, 47, 72, 97, 122, 147, 23, 48, 73, 98, 123, 148, 24, 49, 74, 99, 124, 149, 25, 50, 75, 100, 125, 150) 
HeLa_Fractions  <- Norm_HeLa[vector]

# Create list of all separate dataframes for the fractions
#library(tidyverse)

fractions_names <-  sapply(c(1:50), function(x) {
  if (x%%2 == 0) 
    str_glue("Fraction", (x/2), "_RNAse")
  else 
    str_glue("Fraction", ((x+1)/2), "_Ctrl")
})

# Assign the names to the according 
for (i in c(1:50)) {
  assign(fractions_names[i], HeLa_Fractions[,(3*i-2):(3*i)])
}

# Test
Fraction1_Ctrl
Fraction8_RNAse


```





```{r mean with sd}
# Use sd to single out outliers

mean_sd <- function(x) {
        m <- mean(x)
        s <- sd(x)
       for (i in 1:3)
        if (( (m - 3 * s) > x[i]) || ((m + 3 * s) < x[i])) {x[i] <- NA}
 mean(x, na.rm =TRUE) }
        
```

```{r}

 Test <- Fraction1_Ctrl[1:639,]
 Mean_Test <- apply(Test, 1, mean_sd)
 Mean_Test
```

 
```{r Mean of triplikates}
mean_Ctrl1 <- apply(Fraction1_Ctrl, 1,mean_sd)
mean_Ctrl2 <- apply(Fraction2_Ctrl, 1,mean_sd )
mean_Ctrl3 <- apply(Fraction3_Ctrl, 1,mean_sd )
mean_Ctrl4 <- apply(Fraction4_Ctrl, 1,mean_sd )
mean_Ctrl5 <- apply(Fraction5_Ctrl, 1,mean_sd)
mean_Ctrl6 <- apply(Fraction6_Ctrl, 1,mean_sd)
mean_Ctrl7 <- apply(Fraction7_Ctrl, 1,mean_sd)
mean_Ctrl8 <- apply(Fraction8_Ctrl, 1,mean_sd)
mean_Ctrl9 <- apply(Fraction9_Ctrl, 1,mean_sd)
mean_Ctrl10 <- apply(Fraction10_Ctrl, 1, mean_sd)
mean_Ctrl11 <- apply(Fraction11_Ctrl, 1,mean_sd)
mean_Ctrl12 <- apply(Fraction12_Ctrl, 1,mean_sd)
mean_Ctrl13 <- apply(Fraction13_Ctrl, 1,mean_sd)
mean_Ctrl14 <- apply(Fraction14_Ctrl, 1,mean_sd)
mean_Ctrl15 <- apply(Fraction15_Ctrl, 1,mean_sd)
mean_Ctrl16 <- apply(Fraction16_Ctrl, 1,mean_sd)
mean_Ctrl17 <- apply(Fraction17_Ctrl, 1,mean_sd)
mean_Ctrl18 <- apply(Fraction18_Ctrl, 1,mean_sd)
mean_Ctrl19 <- apply(Fraction19_Ctrl, 1,mean_sd)
mean_Ctrl20 <- apply(Fraction20_Ctrl, 1,mean_sd)
mean_Ctrl21 <- apply(Fraction21_Ctrl, 1,mean_sd)
mean_Ctrl22 <- apply(Fraction22_Ctrl, 1,mean_sd)
mean_Ctrl23 <- apply(Fraction23_Ctrl, 1,mean_sd)
mean_Ctrl24 <- apply(Fraction24_Ctrl, 1,mean_sd)
mean_Ctrl25 <- apply(Fraction25_Ctrl, 1,mean_sd)

mean_RNAse1 <- apply(Fraction1_RNAse, 1,mean_sd)
mean_RNAse2 <- apply(Fraction2_RNAse, 1,mean_sd)
mean_RNAse3 <- apply(Fraction3_RNAse, 1,mean_sd)
mean_RNAse4 <- apply(Fraction4_RNAse, 1,mean_sd)
mean_RNAse5 <- apply(Fraction5_RNAse, 1,mean_sd)
mean_RNAse6 <- apply(Fraction6_RNAse, 1,mean_sd)
mean_RNAse7 <- apply(Fraction7_RNAse, 1,mean_sd)
mean_RNAse8 <- apply(Fraction8_RNAse, 1,mean_sd)
mean_RNAse9 <- apply(Fraction9_RNAse, 1,mean_sd)
mean_RNAse10 <- apply(Fraction10_RNAse, 1,mean_sd)
mean_RNAse11 <- apply(Fraction11_RNAse, 1,mean_sd)
mean_RNAse12 <- apply(Fraction12_RNAse, 1,mean_sd)
mean_RNAse13 <- apply(Fraction13_RNAse, 1,mean_sd)
mean_RNAse14 <- apply(Fraction14_RNAse, 1,mean_sd)
mean_RNAse15 <- apply(Fraction15_RNAse, 1,mean_sd)
mean_RNAse16 <- apply(Fraction16_RNAse, 1,mean_sd)
mean_RNAse17 <- apply(Fraction17_RNAse, 1,mean_sd)
mean_RNAse18 <- apply(Fraction18_RNAse, 1,mean_sd)
mean_RNAse19 <- apply(Fraction19_RNAse, 1,mean_sd)
mean_RNAse20 <- apply(Fraction20_RNAse, 1,mean_sd)
mean_RNAse21 <- apply(Fraction21_RNAse, 1,mean_sd)
mean_RNAse22 <- apply(Fraction22_RNAse, 1,mean_sd)
mean_RNAse23 <- apply(Fraction23_RNAse, 1,mean_sd)
mean_RNAse24 <- apply(Fraction24_RNAse, 1,mean_sd)
mean_RNAse25 <- apply(Fraction25_RNAse, 1,mean_sd)

# Dataframe with mean
mean_HeLa <- data.frame(mean_Ctrl1, mean_RNAse1, mean_Ctrl2, mean_RNAse2, mean_Ctrl3,mean_RNAse3, mean_Ctrl4, mean_RNAse4,  mean_Ctrl5, mean_RNAse5, mean_Ctrl6, mean_RNAse6, mean_Ctrl7, mean_RNAse7, mean_Ctrl8, mean_RNAse8, mean_Ctrl9, mean_RNAse9, mean_Ctrl10, mean_RNAse10, mean_Ctrl11, mean_RNAse11, mean_Ctrl12, mean_RNAse12, mean_Ctrl13, mean_RNAse13, mean_Ctrl14, mean_RNAse14, mean_Ctrl15, mean_RNAse15, mean_Ctrl16, mean_RNAse16, mean_Ctrl17, mean_RNAse17, mean_Ctrl18, mean_RNAse18, mean_Ctrl19, mean_RNAse19, mean_Ctrl20, mean_RNAse20, mean_Ctrl21, mean_RNAse21, mean_Ctrl22, mean_RNAse22, mean_Ctrl23, mean_RNAse23, mean_Ctrl24, mean_RNAse24, mean_Ctrl25, mean_RNAse25)
```

``` {r label = clean up}
#clean up datasets
# Control

HeLa_Ctrl_mean = mean_HeLa %>% select(contains("Ctrl"))
# RNAse
HeLa_RNAse_mean = mean_HeLa %>% select(contains("RNA"))

```








# Checking on the normalization

Next, the results of the clean-up were compared. We plotted the data pre- and post-normalization for six proteins. Three of which were sure "shifters" and three that were found not to be RNA-dependent.

"Shifters": SIN3A (transcriptional repressor), HDAC1 (Histone deacetylase 1), HNRPU (Heterogeneous nuclear ribonucleoprotein U)

"Non-shifters": ASNS (Asparagine synthetase), MCM2 (DNA replication licensing factor MCM2), MCM3 (DNA replication licensing factor MCM3)

```{r Comparing pre- and post-normalization}
fraction_index <- c(1:25)

# Repeat the following code block for the six test proteins ctrl vs RNase and pre vs post normalization

# Function to create comparison plots

compare_pre_post <- function(protein, y_limit_pre, y_limit_post) {

  par(mfrow = c(1,2))

  plot(fraction_index, HeLa_Ctrl1[protein,], type = 'l', col = 'forestgreen', # Control pre
      xlab = "Fractions",
      ylab = "Protein amount [arbitrary unit]",
      ylim = c(0,y_limit_pre),
      main = paste(protein, "pre-normalization"))
   lines(x = fraction_index, y = HeLa_RNAse1[protein,], type = 'l', col = 'firebrick2') # RNase pre
   legend(x = "topright",                      # Position
       legend = c("ctrl", "RNase"),           # Legend texts
  col = c('darkgreen', 'red'),           # Line colors
       lwd = 2)                               # Line width

  plot(fraction_index, HeLa_Ctrl_mean[protein,], type = 'l', col = 'forestgreen', # Control post
     xlab = "Fractions",
     ylab = "Protein amount [%]",
     ylim = c(0,y_limit_post),
     main = paste(protein, "post-normalization"))
  lines(x = fraction_index, y = HeLa_RNAse_mean[protein,], type = 'l', col = 'firebrick2') # RNase post
  legend(x = "topright",            
       legend = c("ctrl", "RNase"),           
       col = c('darkgreen', 'red'),         
       lwd = 2) 
}
```

Now we will apply the function to our selection of proteins:

```{r}
# Shifters
compare_pre_post("SIN3A_HUMAN", 3500000, 0.1) #SIN3A
compare_pre_post("HDAC1_HUMAN", 6000000, 0.11) #HDAC1
compare_pre_post("HDAC2_HUMAN", 6500000, 0.15) #HDAC2
compare_pre_post("RFC2_HUMAN", 2500000, 0.05) #RFC2

# Non-Shifters
compare_pre_post("ASNS_HUMAN", 2500000, 0.02) #ASNS
compare_pre_post("MCM2_HUMAN", 15000000, 0.5) #MCM2
compare_pre_post("MCM3_HUMAN", 17000000, 0.3) #MCM3

```


The scale should represent percentages now with the area under the curve equaling 1. Furthermore, peaks should become more visible as well as first "shifts".


## Test if data is normally distributed

### Shapiro-Wilk test

 n should be greater than 3 and no greater than 5000 (we are looking at 3 values per protein)
- in the sample there shouldn't be identical values (exclude from test)
- H0 says that the data is normally distributed
- significance level α = 5 % --> H0 is not rejected, if p > α

```{r Shapiro-Wilk test function}
# Define Shapiro test function
shapiro_testing <- function(x) {
  if (diff(range(x)) == 0) 
      list()
  else shapiro.test(x)
}

# Create list of all separate dataframes for the fractions
library(tidyverse)

fractions_names <-  sapply(c(1:50), function(x) {
  if (x%%2 == 0) 
    str_glue("Fraction", (x/2), "_RNAse")
  else 
    str_glue("Fraction", ((x+1)/2), "_Ctrl")
})


# Define function to apply shapiro testing to list of names for all fractions
shapiro_on_name_list <- function(list) {
  mean = c()
  for (i in 1:length(list)) {
    df = get(list[i])
    list_results <- apply(df, 1, shapiro_testing)
    p_values <- unlist(lapply(list_results, function(x) {x$p.value}))
    # print p mean value for each fraction
    mean = c(mean, mean(p_values))
  }
  mean
}

# Apply testing to data and testing if all values are greater than 5 %
shapiro_on_name_list(fractions_names) > 0.05
```

Following the Shapiro-Wilk test, we can expect our data three replicate values per protein to be normally distributed.


### Graph via qqplot

```{r qqplot on raw data}
 # Function for qqplot and 
qqplot_line <-  function(x) {
  qqnorm(x)
  qqline(x, col ="red")
}

# Plot first five proteins of Fraction 1 Ctrl
apply(Fraction1_Ctrl[1:5,], 1, qqplot_line)
```
QQplots with three values only do not have great significance. 


### Histogram

```{r histogram for raw data}
apply(Fraction1_Ctrl[1:5,], 1, hist)
```

A histogram with three values only is also not a valid method to test for normal distribution.


## Maxima

### Separate dataframes Ctrl vs RNase

For further analysis, all fractions belonging to the control group and those treated with RNase are saved in separate dataframes.

```{r}
# All control
All_ctrl_norm <- HeLa_Fractions %>% select(contains("Ctrl"))
# All RNase
All_RNAse_norm <- HeLa_Fractions %>% select(contains("RNAse"))




# Create list of all separate dataframes for the fractions
library(tidyverse)

fractions_names_RNAse <-  sapply(c(1:25), function(x) {
    str_glue("Fraction", x, "_RNAse")
})

fractions_names_Ctrl_ <-  sapply(c(1:25), function(x) {
    str_glue("Fraction", x, "_Ctrl")
})



# Define function to calculate mean of all proteins for all fractions

mean_on_name_list <- function(list) {
  mean_ctrl = data.frame()
  for (i in 1:length(list)) {
    df = get(list[i])
    fraction_mean <- apply(df, 1, mean)
    mean_ctrl = cbind(mean_ctrl, fraction_mean)
  }
  mean_ctrl
}

# mean_on_name_list(fractions_names_RNAse)

```

### Local maxima

For all proteins - both in the control group and treated with RNase - the local maxima were determined.

For this purpose, the protein content (y-value) was compared to m neighbors right and left of the analyzed fraction (x-position).


### Absolute maxima

For all proteins - both in the control group and treated with RNase - the absolute maxima were determined.


```{r}
# Maxima

find_peaks <- function (x, m = 2){
     shape <- diff(sign(diff(x, na.pad = FALSE)))
     pks <- sapply(which(shape < 0), FUN = function(i){
        z <- i - m + 1
        z <- ifelse(z > 0, z, 1)
        w <- i + m + 1
        w <- ifelse(w < length(x), w, length(x))
        if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(numeric(0))
    })
     pks <- unlist(pks)
     pks
     
     if ( sum(x[1]>x[2:(m+1)]) == 2 ) {pks <- c(pks, 1)} 
     if ( sum(x[25]>x[24:(25-m)]) == 2 ) {pks <- c(pks, 25)}
     pks <- unlist(pks)
     pks
}

#absolute/global maxima
#absolute/global maxima

absolute_max_ctrl <- apply(HeLa_Ctrl_mean, 1, max)
absolute_max_RNAse <- apply(HeLa_RNAse_mean, 1, max)
absolute_max_ctrl
absolute_max_RNAse

#x is the dataframe with all percentage values of ctrl or RNAse treated sample. Function relevant_peaks gives us the fraction numbers of the relevant peaks (contain more than 2% of the protein).

rel_peaks_ctrl <- apply(HeLa_Ctrl_mean, 1, function(x){
              list <- find_peaks(x)
              list <- list[x[list] > 2]
              list <- unlist(list)
              list
})

rel_peaks_RNAse <- apply(HeLa_RNAse_mean, 1, function(x){
              list <- find_peaks(x)
              list <- list[x[list] > 2]
              list <- unlist(list)
              list
})

rel_peaks_ctrl
rel_peaks_RNAse

```

```{r global max comparison}
fracs_ctrl <- max.col(HeLa_Ctrl_mean)
fracs_RNAse <- max.col(HeLa_RNAse_mean)

```

```{r peaks 25%}
peaks_ctrl_25 <- apply(HeLa_Ctrl_mean, 1, function(x){
              list <- find_peaks(x)
              k <- 1
              list <- list[x[list] >= (absolute_max_ctrl[k]/4)]
              k <- k + 1             
              list <- unlist(list)
              list
})

peaks_RNAse_25 <- apply(HeLa_RNAse_mean, 1, function(x){
              list <- find_peaks(x)
              k <- 1
              list <- list[x[list] >= (absolute_max_RNAse[k]/4)]
              k <- k + 1             
              list <- unlist(list)
              list
})

abs_max_both <- data.frame(absolute_max_ctrl, fracs_ctrl, absolute_max_RNAse, fracs_RNAse)
```


## Shift Erkennung
```{r}
# Globale Maxima für CNTRL und RNAse in eine Spalte einer Tabelle oder separat

# Lokale Maxima ebenfalls

# Maxima auswählen: Laut Literatur (Maiwens Publikation) alle Maxima >= 25 % des globalen Maximums berücksichtigen.

 # Als erstes müssen wir definieren ob der Verlust in der einen Fraktion identisch mit dem Gain in der anderen ist --> Ermöglicht uns zu erkennen ob mehrere Peaks nach RNASE Treatment zu erwarten sind. Dazu vergleichen wir die "Area under Curve" oder halt die Differenzen der beiden Fraktionen.

# Parameter ob shift relevant: Änderung > 1 Fraktion

# Wie bestimmen ? --> "x" Values aka Fraktion bestimmen und subtrahieren --> CNTRL - RNASE wenn Value > 1 (Links Verschiebung) bzw. < -1 (Rechts Verschiebung) dann ist der Shift vorhanden. --> 2 Listen anlegen. Sollte auch nur ganzzahlige Werte liefern.  Zu Berücksichtigen sind die Proteine die mehrere Peaks haben bei RNASE --> seperate Liste. Lässt sich vllt. mit der count Funktion umsetzen. Ausprobieren mit den globalen Maxima.

# Beispiel: 
#RFC2 ist bei CNTRL in Fraktion 21 gloables Maximum . In der RNASE Sample Fraktion 9 macht in der Rechnung: 21-9=12 bedeutet Linksverschiebung. Anschließend "Area under Curve" oder Maxima:
# Beispiel:RFC2_CNTRL(9)=1000, RFC2_CNTRL(21)=15000, RFC2_RNASE(9)=17500, RFC2_RNASE(21)= 200 --> Delta(9) = Delta(21) --> Delta(9)=16500 Delta(21)=14800. Wir sehen die Werte sind nicht gleich, da es biologische Samples sind ggf. +/- 10% erlauben. Vermutlich ist die Varinate mit der Area under Curve die elegantere.
```

```{r calculating x-shift}
i <- c(1:7081)
x_shifts <- c()
for(x in i){x_shifts[x] <- fracs_ctrl[x] - fracs_RNAse[x]
}
abs_max_both$x_shifts <- x_shifts

i <- c(1:7081)
y_shifts <- c()
for(x in i){y_shifts[x] <- absolute_max_ctrl[x] - absolute_max_RNAse[x]
}
abs_max_both$y_shifts <- y_shifts
```

## Statistische Tests
```{r}
# WENN die Werte Normalverteilt sind und wir das einfach nur aufgrund der Normalisierung nicht sehen: a) Erst F-Test um die Varianzen zu vergleichen b) Unpaired T-Test weil wir zwar eine einheitliche Grundgesamtheit haben aber diese unterschiedlich behandelt haben. Muss da mal Niklas fragen. 

#Beispiel mit Fe-Werten von Mäusen aus meiner Ausbildung die wir damals händisch gerechnet haben.

Fe_before <- c(13.6, 13.0, 13.7, 13.9, 13.4)
Fe_after <- c(12.0, 12.3, 13.1, 12.5, 13.0)

Fe_ttest <- t.test(Fe_before, Fe_after, var.equal = TRUE) #Unpired
Fe_ttest

#Wir sehen der p-value ist 0.006618 und damit kleiner als die Signifikanzgrenze (a) bei Konfidenzintervall 95 % a = 0.05 dementsprechend ist es signifikant.

# Man kann auch argumentieren, dass die Werte gepaart sind Vor-Treatment und nach Treatment. So habe ich in der Ausbildung gerechnet. 

Fe_test_paired <- t.test(Fe_before, Fe_after, paired = TRUE)
Fe_test_paired

#Wilcoxon Test for paired samples if not normally ditributed was bei unseren Daten sehr wahrscheinlich der Fall sein wird. 

```

```{r k means clustering}
install.packages('corrplot')
install.packages('cluster')
install.packages('factoextra')
library(corrplot)# Clustering
library(cluster) 
library(factoextra)
```


```{r k means clustering}
silhouette_score <- function(k){
  km <- kmeans(abs_max_both[,5:6], centers = k, nstart=15)
  ss <- silhouette(km$cluster, dist(abs_max_both[,5:6]))
  mean(ss[, 3])
}
k <- 2:10
avg_sil <- sapply(k, silhouette_score)
plot(k, type='b', avg_sil, xlab='Number of clusters', ylab='Average Silhouette Scores', frame=FALSE)

```

```{r}
install.packages('factoextra')
library(factoextra)

fviz_nbclust(abs_max_both[,5:6], kmeans, method='silhouette')
```

```{r}
kmean <- kmeans(abs_max_both[,5:6], centers = 4, iter.max = 25, nstart = 50)
```

```{r plotting cluster}
install.packages('ggpubr')
install.packages("readxl")
install.packages("FactoMineR")
library(ggpubr)
library(readxl)
library(FactoMineR)
```


```{r plotting cluster}
fviz_cluster(kmean, data = abs_max_both[,5:6],
             palette = c("#2E9FDF", "#00AFBB", "#E7B800"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             )
```

